require "world.entity"
require "world.weather"

----- NPC Class ------

NPC = Entity:new()

--[[{
  name = "Name", 
  age = 0, 
  gender = "", 
  mood = 0, 
  receptiveness = 0, 
  relationship = "", 
  flirtiness = 0,
  type = "NPC"
}]]

RELATIONSHIPS = {
    "single",
    "dating",
    "engaged",
    "married",
    "divorced",
    "widowed"
}

FEMALE_NAMES = {
    "Audrey",
    "Cami",
    "Chelsey",
    "Danielle",
    "Kylie",
    "Lauren",
    "Makenna",
    "Megan",
    "Rachel",
    "Sarah",
    "Shirley",
    "Tessa"
}

MALE_NAMES = {
    "Brandon",
    "Calvin",
    "Cole",
    "David",
    "Derek",
    "Derik",
    "Emmett",
    "Griffin",
    "Jason",
    "Johnathan",
    "Joseph",
    "Steve",
    "Shawn"
}

LAST_NAMES = {
    "Anderson",
    "Burton",
    "Cook",
    "Fischer",
    "Jensen",
    "McAllister",
    "Mines",
    "Newman",
    "Olsen",
    "Owen",
    "Turley",
    "Watts"
}

lostMsg = "Which of you men, if you had one hundred sheep, and lost one of them, "
        .. "wouldn't leave the ninety-nine in the wilderness, " 
        .. "and go after the one that was lost, until he found it? "
 
----- NPC Construtor ------

function NPC:new(name, x, y, age, gender, receptiveness, relationship, flirtiness)
    local o = Entity.new(self, name, x, y)
  
    o.maxSpeed = 2
    o.acceleration = 1
  
    o.name = name
    o.type = "NPC"
    o.age = age
    o.gender = gender
    o.receptiveness = math.clamp(receptiveness, 0, 100) -- scale 0 to 100 (not receptive to very receptive)
    o.spawned = false

    if age < 18 then
        o.relationship = RELATIONSHIPS[1]
    else 
        o.relationship = relationship
    end

    o.flirtiness = math.clamp(flirtiness, 0, 100) -- scale 0 to 100 (not flirtatious to very flirtatious)
    o.hitBox = {x1 =- .15, y1 =- .15, x2 = .15, y2 = .15}
    o.arrow = false --arrow pointing at their head to indicate the player can interact with them
    return o
end

----- NPC Getters -----

function NPC:getAge () 
    return self.age
end

function NPC:getGender () 
    return self.age
end

function NPC:getReceptiveness () 
    return self.receptiveness
end

function NPC:getrelationship () 
    return self.relationship
end

function NPC:getFlirtiness () 
    return self.flirtiness
end

----- NPC Setters -----

function NPC:setAge (age)
    self.age = age
end

function NPC:setReceptiveness (receptiveness)
    self.receptiveness = math.clamp(receptiveness, 0, 100)
end

function NPC:setrelationship (relationship)
    self.relationship = relationship
end

function NPC:setFlirtiness (flirtiness)
    self.flirtiness = math.clamp(flirtiness, 0, 100)
end


----- NPC Methods -----

--[[
NPC:generate
count - the number of NPCs to generate
weather - the weather generated by the level
nodes - the spawn nodes on the map
]]
function NPC:generate(count, weather, nodes) 
    math.randomseed(os.time())
    local npcs = {}

    local minAge, maxAge = 8, 40
    local minMood, maxMood = 0, 100
    local minReceptiveness, maxReceptiveness = 0, 100
    local minFlirtiness, maxFlirtiness = 0, 100

    local half = math.ceil(count / 2)

    local name, x, y, age, gender, receptiveness, relationship, flirtiness -- variables used when inserting

    local used_nodes = {}
    local index

    for i = 1, count do

        if i <= half then
            name = FEMALE_NAMES[math.random(1, #FEMALE_NAMES)]
            gender = "female"
        else
            name = MALE_NAMES[math.random(1, #MALE_NAMES)]
            gender = "male"    
        end
        
        name = name .. " " .. LAST_NAMES[math.random(1, #LAST_NAMES)]
        age = math.random(minAge, maxAge)
        receptiveness = math.floor(math.random(minReceptiveness, maxReceptiveness) * weather.ReceptivenessModifier)
        relationship = RELATIONSHIPS[math.random(1, #RELATIONSHIPS)]
        flirtiness = math.floor(math.random(minFlirtiness, maxFlirtiness) * weather.FlirtinessModifier)

        -- verify that node hasn't been used (temp check until despawning NPCs is implemented)
        if count <= #nodes then
            while true do
                index = math.random(1, #nodes)
                if table.indexOf(used_nodes, index) == -1 then
                    print(index)
                    table.insert(used_nodes, index)
                    break
                end
            end
        else
            index = math.random(1, #nodes)
        end

        x = nodes[index].LocationX
        y = nodes[index].LocationY

        table.insert(npcs, NPC:new(name, x, y, age, gender, receptiveness, relationship, flirtiness))
    end 

    return npcs
end

function NPC:getNode(nodes, x, y)
    for i, node in pairs(nodes) do
        if node.LocationX == x and node.LocationY == y then
            return node
        end
    end

    return nil
end

function NPC:update(dt, world)
    if self.interaction then
        return
    end

    local x = self.position.x
    local y = self.position.y

    local node = NPC:getNode(world.map.PathingGraph.Nodes, x, y)

    if node ~= nil then
        -- choose new direction
        local target = node.Edges[math.random(1, #node.Edges)]
        local targetX = target.LocationX
        local targetY = target.LocationY

        if targetX > x then
            self.facing = "r"
        elseif targetX < x then
            self.facing = "l"
        elseif targetY > y then
            self.facing = "d"
        elseif targetY < y then
            self.facing = "u"
        else
            error(self.name .. " couldn't decide where to go. Send help.")
        end
    end

    print("Name: " .. self.name .. " [X: " .. x .. ", Y: " .. y .. "]" .. " Moving: " .. self.facing)

    local mvmt = 0.025
    local rnd = 3

    -- NPC moves
    if self.facing == "r" then
        self.position.x = math.round(self.position.x + mvmt, rnd)
    elseif self.facing == "l" then
        self.position.x = math.round(self.position.x - mvmt, rnd)
    elseif self.facing == "u" then
        self.position.y = math.round(self.position.y - mvmt, rnd)
    elseif self.facing == "d" then
        self.position.y = math.round(self.position.y + mvmt, rnd)
    else
        error(self.name .. " forgot which way to walk. Awkward.")
    end

    if self.position.x < 0 or 
        self.position.x > world.map.MapWidth or 
        self.position.y < 0 or 
        self.position.x > world.map.MapHeight then
        error(lostMsg .. self.name .. " is lost.")
    end

end

function NPC:getStats ()
    return string.format("%s\n%s\n%s\n%s\n%s\n%s\n", 
    "Name: " .. self.name, 
    "Age: " .. self.age, 
    "Gender: " .. self.gender,
    "Receptiveness: " .. self.receptiveness, 
    "Relationship status: " .. self.relationship, 
    "flirtiness: " .. self.flirtiness)
end

----- Helper Methods -----

function math.clamp(low, n, high) 
    return math.min(math.max(n, low), high) 
end

function math.round(num, numDecimalPlaces)
    local mult = 10^(numDecimalPlaces or 0)
    return math.floor(num * mult + 0.5) / mult
end

function table.indexOf(t, object)
    if type(t) ~= "table" then 
        error("table expected, got " .. type(t), 2) 
    end

    for i, v in pairs(t) do
        if object == v then
            return i
        end
    end

    return -1
end